1. 1stProblem - 81. Search in Rotated Sorted Array II (Leet code)
+ Native search => O(n)
+ Binary search => O(logn) (mid = target break; mid < target start = mid + 1; mid > target end = mid - 1)
	=> 2 dãy sắp xếp tăng dần => Phần tử start của dãy 1 luôn luôn lớn hơn các phần tử của dãy 2
	=> Xét vị trí của mid (start + (end - start) / 2) và target xem đang nằm trong dãy nào để tìm ra khoảng binary search kế tiếp
	=> Các phần tử trùng nhau => không thể áp dụng binary search => so sánh với phần tử start => nếu bằng thì tăng start lên 1 để có khoảng binary search kế tiếp 
	
2. 2ndProblem - 33. Search in Rotated Sorted Array (Leet code)
+ Binary search => find the index of pivot => compare with last index value (vì dãy tách thành 2 dãy tăng dần, phần tử cuối là phần tử lớn nhất của dãy nhỏ, phần tử chốt là phần tử lớn nhất trong toàn dãy)

3. 3rdProblem - 5. Longest Palindromic Substring (Leet code)
+ Exhaustive search => Lấy từng chuỗi O(n^2) => Kiểm tra xem chuỗi có phải là palindromic không O(n) => Chi phí là O(n^3)
+ Giảm không gian tìm kiếm
	+ Dùng biến giữ giá trị lớn nhất của chuỗi con hiện tại, nếu cấu hình kiểm tra có độ dài nhỏ hơn thì bỏ qua.
+ Sắp xếp lại không gian tìm kiếm
	+ Bắt đầu tìm từ chuỗi dài nhất rùi giảm dần đến chuỗi nhỏ hơn
+ DP 
	P[i,i] = true // 1 letter
	P[i, i + 1] = (s[i] == s[i + 1]) // 2 letters
	P[i,j] = P[i + 1, j - 1] && s[i] == s[j] // >= 3 letters
		
4. 4thProblem - REPROAD - Repair road (spoj)
+ Exhaustive search => Lấy từng cấu hình O (n^2) => Kiểm tra xem độ dài cấu hình (đoạn đang xét) có lớn hơn max && kiểm tra đoạn đó có phải là đoạn thỏa mãn lượng số 0 < K (cost) hay không
+ Stack 
Dùng tham lam: Nhận xét thấy rằng việc khác nhau giữa hai cấu hình hợp lệ (i1,j1) và (i2, j2)
trong đó i1 <i2, j1 < j2 phải thỏa mãn: Số số 0 nằm trong khoảng i1 đến i2 nhỏ hơn hoặc bằng số
số 0 nằm trong j1 đến j2.
Do đó, việc tính toán cấu hình tiếp theo từ cấu hình hiện có (i1, j1) bằng cách tăng i1 lên thành i2
với số số 0 nằm trong i1 và i2 là 1 số 0. Tương tự với j1 và j2.
Cấu hình đầu tiên hợp lệ là cấu hình đã sửa K đoạn hỏng đầu tiên.
Bằng cách stack lại các vị trí của i, ta có thể loại bỏ việc tìm i2 -> giảm độ phức tạp xuống còn
O(n)

=> 1 vòng for duyệt toàn bộ dãy => Kiểm tra phần tử đó là 0 hay 1
	=> Nếu là 0 => nếu cost < K => tăng cost và len lên 1 đơn vị
					nếu không => tính lại đoạn khác len = i - q.front(), q.pop_front(); (số 0 mới đc đưa vào vị trí neo sau khi K lần sửa đã được áp dụng)
				đưa i vào stack là mốc của số 0 hiện tại
	+ Nếu không thì tăng len lên (vì đoạn đó là 1)
	+ Check kết quả bằng max của len và kết quả

5. 5thProblem - Liệt kê cấu hình cho bài toán n!
	+ Phương pháp sinh
		Khởi đầu với 1 cấu hình tăng dần từ 1 -> n (nhưng khi code thì nên tạo mảng có n + 1 phần tử, với phần tử đầu tiên là 0)
		Tìm dãy con giản dần dài nhất
		Tim phần tử đầu tiên trong dãy con đó lớn hơn i - 1 (phần tử đứng kế ngày trc dãy con)
		Đảo 2 phần tử cho nhau
		Đổi dãy con giảm dần thành dãy con tăng dần
		Kết thúc khi dãy toàn phần tử giảm dần
	+ Quay lui
		Dùng 1 mảng đánh dấu
		Thử từ 1
		Duyệt từ v = 1 -> n
		Neu mark[v] chưa đánh dấu => gán giá trị => Nếu là cấu hình cuối (i == n) => In giá trị
														Nếu không => Đánh dấu phần tử thứ v là đã chọn => Thử với i + 1 => Bỏ đánh dấu phần tử thứ v
6. 6thProblem - Liệt kê cấu hình cho bài toán Akn (n!/)n-k)!)
Tương tự bài toán 5 nhưng tốt nhất nên dùng thuật toán quay lui với điều kiên thay n bằng k ở cấu hình cuối

7. 7th Problem - Liệt kê cấu hình cho bài toán Ckn = Akn/n!
	+ Phương pháp sinh
		1. Tìm từ cuối lên đầu dãy cho đến khi gặp phần tử x(i) chưa đạt giới hạn trên n - k + i.
		2. Tăng x(i) lên một đơn vị.
		3. Đặt lại tất cả các phần tử phía sau bằng giới hạn dưới.
	+ Quay lui
		Xét tất cả các cách chọn x1 từ 1 (x0 + 1) đến n - k + 1, với mỗi giá trị đó xét tất cả các lựa chọn x2 từ x1+1 đến n - k + 2, ...., cứ như vậy đến x(k) thì ta có cấu hình cần liệt kê.
		=> giá trị v chạy từ x[i - 1] + 1 -> n - k + i
		Thử từ 1 -> n
		
8. 8th Problem - Liệt kê dãy nị phân có độ dài n
	+ Quay lui
		Giá trị gán v chạy trong khoảng 0, 1
		Thử từ i = 1 -> n
9. 9th Problem - https://www.spoj.com/problems/BURGLARY/
	+ Liệt kê 2^n dãy nhị phân, với 1 ứng với phần tử j đc chọn, và 0 không được chọn
	+ Chia đôi dãy, dùng map (Liệt kê tất cả các dãy con của n/2) => kiểm tra từng dãy có tổng nào chọn được bằng nhiều số K không => Tổng hợp lại. Nếu từng dãy có value sum = -2 thì bỏ, không thì tính số lượng phần tử hiện tại bằng tổng, kiểm tra giá trị trước xem có khác không, nếu khác thì cho là -2, không thì lưu lại.
		Lưu ý trong lúc sinh phải kiếm tra tổng bằng 0 có hình thành bằng các phần tử 0 không, nếu có thì cho bằng -2, không thì cho bằng 0.
		Các tổng khác 0 thì sẽ kiểm tra xem đã update vào map chưa, nếu chưa thì lưu value bằng số lượng phần tử, nếu rồi thì lưu value = -2
10. 10th Problem - QuickSort