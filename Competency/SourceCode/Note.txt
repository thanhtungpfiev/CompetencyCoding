1. 1stProblem - 81. Search in Rotated Sorted Array II (Leet code)
+ Native search => O(n)
+ Binary search => O(logn) (mid = target break; mid < target start = mid + 1; mid > target end = mid - 1)
	=> 2 dãy sắp xếp tăng dần => Phần tử start của dãy 1 luôn luôn lớn hơn các phần tử của dãy 2
	=> Xét vị trí của mid (start + (end - start) / 2) và target xem đang nằm trong dãy nào để tìm ra khoảng binary search kế tiếp
	=> Các phần tử trùng nhau => không thể áp dụng binary search => so sánh với phần tử start => nếu bằng thì tăng start lên 1 để có khoảng binary search kế tiếp 
	
2. 2ndProblem - 33. Search in Rotated Sorted Array (Leet code)
+ Binary search => find the index of pivot => compare with last index value (vì dãy tách thành 2 dãy tăng dần, phần tử cuối là phần tử lớn nhất của dãy nhỏ, phần tử chốt là phần tử lớn nhất trong toàn dãy)

3. 3rdProblem - 5. Longest Palindromic Substring (Leet code)
+ Exhaustive search => Lấy từng chuỗi O(n^2) => Kiểm tra xem chuỗi có phải là palindromic không O(n) => Chi phí là O(n^3)
+ Giảm không gian tìm kiếm
	+ Dùng biến giữ giá trị lớn nhất của chuỗi con hiện tại, nếu cấu hình kiểm tra có độ dài nhỏ hơn thì bỏ qua.
+ Sắp xếp lại không gian tìm kiếm
	+ Bắt đầu tìm từ chuỗi dài nhất rùi giảm dần đến chuỗi nhỏ hơn
+ DP 
	P[i,i] = true // 1 letter
	P[i, i + 1] = (s[i] == s[i + 1]) // 2 letters
	P[i,j] = P[i + 1, j - 1] && s[i] == s[j] // >= 3 letters
		
4. 4thProblem - REPROAD - Repair road (spoj)
+ Exhaustive search => Lấy từng cấu hình O (n^2) => Kiểm tra xem độ dài cấu hình (đoạn đang xét) có lớn hơn max && kiểm tra đoạn đó có phải là đoạn thỏa mãn lượng số 0 < K (cost) hay không
+ Stack 
Dùng tham lam: Nhận xét thấy rằng việc khác nhau giữa hai cấu hình hợp lệ (i1,j1) và (i2, j2)
trong đó i1 <i2, j1 < j2 phải thỏa mãn: Số số 0 nằm trong khoảng i1 đến i2 nhỏ hơn hoặc bằng số
số 0 nằm trong j1 đến j2.
Do đó, việc tính toán cấu hình tiếp theo từ cấu hình hiện có (i1, j1) bằng cách tăng i1 lên thành i2
với số số 0 nằm trong i1 và i2 là 1 số 0. Tương tự với j1 và j2.
Cấu hình đầu tiên hợp lệ là cấu hình đã sửa K đoạn hỏng đầu tiên.
Bằng cách stack lại các vị trí của i, ta có thể loại bỏ việc tìm i2 -> giảm độ phức tạp xuống còn
O(n)

=> 1 vòng for duyệt toàn bộ dãy => Kiểm tra phần tử đó là 0 hay 1
	=> Nếu là 0 => nếu cost < K => tăng cost và len lên 1 đơn vị
					nếu không => tính lại đoạn khác len = i - q.front(), q.pop_front(); (số 0 mới đc đưa vào vị trí neo sau khi K lần sửa đã được áp dụng)
				đưa i vào stack là mốc của số 0 hiện tại
	+ Nếu không thì tăng len lên (vì đoạn đó là 1)
	+ Check kết quả bằng max của len và kết quả

5. 5thProblem - Liệt kê cấu hình cho bài toán n!
	+ Phương pháp sinh
		Khởi đầu với 1 cấu hình tăng dần từ 1 -> n (nhưng khi code thì nên tạo mảng có n + 1 phần tử, với phần tử đầu tiên là 0)
		Tìm dãy con giản dần dài nhất
		Tim phần tử đầu tiên trong dãy con đó lớn hơn i - 1 (phần tử đứng kế ngày trc dãy con)
		Đảo 2 phần tử cho nhau
		Đổi dãy con giảm dần thành dãy con tăng dần
		Kết thúc khi dãy toàn phần tử giảm dần
	+ Quay lui
		Dùng 1 mảng đánh dấu
		Thử từ 1
		Duyệt từ v = 1 -> n
		Neu mark[v] chưa đánh dấu => gán giá trị => Nếu là cấu hình cuối (i == n) => In giá trị
														Nếu không => Đánh dấu phần tử thứ v là đã chọn => Thử với i + 1 => Bỏ đánh dấu phần tử thứ v
6. 6thProblem - Liệt kê cấu hình cho bài toán Akn (n!/)n-k)!)
Tương tự bài toán 5 nhưng tốt nhất nên dùng thuật toán quay lui với điều kiên thay n bằng k ở cấu hình cuối

7. 7th Problem - Liệt kê cấu hình cho bài toán Ckn = Akn/n!
	+ Phương pháp sinh
		1. Tìm từ cuối lên đầu dãy cho đến khi gặp phần tử x(i) chưa đạt giới hạn trên n - k + i.
		2. Tăng x(i) lên một đơn vị.
		3. Đặt lại tất cả các phần tử phía sau bằng giới hạn dưới.
	+ Quay lui
		Xét tất cả các cách chọn x1 từ 1 (x0 + 1) đến n - k + 1, với mỗi giá trị đó xét tất cả các lựa chọn x2 từ x1+1 đến n - k + 2, ...., cứ như vậy đến x(k) thì ta có cấu hình cần liệt kê.
		=> giá trị v chạy từ x[i - 1] + 1 -> n - k + i
		Thử từ 1 -> n
		
8. 8th Problem - Liệt kê dãy nị phân có độ dài n
	+ Quay lui
		Giá trị gán v chạy trong khoảng 0, 1
		Thử từ i = 1 -> n

9. 9th Problem - https://www.spoj.com/problems/BURGLARY/
	+ Liệt kê 2^n dãy nhị phân, với 1 ứng với phần tử j đc chọn, và 0 không được chọn
	+ Chia đôi dãy, dùng map (Liệt kê tất cả các dãy con của n/2) => kiểm tra từng dãy có tổng nào chọn được bằng nhiều số K không => Tổng hợp lại. Nếu từng dãy có value sum = -2 thì bỏ, không thì tính số lượng phần tử hiện tại bằng tổng, kiểm tra giá trị trước xem có khác không, nếu khác thì cho là -2, không thì lưu lại.
		Lưu ý trong lúc sinh phải kiếm tra tổng bằng 0 có hình thành bằng các phần tử 0 không, nếu có thì cho bằng -2, không thì cho bằng 0.
		Các tổng khác 0 thì sẽ kiểm tra xem đã update vào map chưa, nếu chưa thì lưu value bằng số lượng phần tử, nếu rồi thì lưu value = -2

10. 10th Problem - QuickSort

11. 11th Problem - Searching
	+ Sequence search - Tìm kiềm lần lượt dãy khóa -> O(n)
	+ Binay search -> Dãy khóa đã sắp xếp -> Chia đôi dãy khóa để tìm -> O(logn) 
		mid = start + (end - start) / 2
		while (start <= end) search key and update start/end bằng mid

12. 12th Problem - Merge sort - TopDown 
	if (i < iMiddle && (j >= iEnd || A[i] < A[j])) { //nếu dãy bên trái vẫn còn phần tử kết hợp với dãy bên phải hết phần tử hoặc cả hai dãy vẫn còn phần tử nhưng phần tử bên trái nhỏ hơn phần tử bên phải.
	
13. 13th Problem - Tìm tập con liên tục có tổng lớn nhất
	+ Vét cạn -> tính tổng từng tập con -> tìm tập có tổng lớn nhất -> O(n^3)
	+ Áp dụng chia để trị ta có thể giải bài toán này theo cách sau:

Chia mảng ban đầu thành hai mảng
Trả ra tổng lớn nhất của:
Tổng lớn nhất của mảng bên trái (bằng cách gọi đệ quy)
Tổng lớn nhất của mảng bên phải (bằng cách gọi đệ quy)
Tổng lớn nhất của mảng gồm phần tử cả phần tử ở giữa
	+ Thuật toán Kadane
	
Initialize:
    max_so_far = INT_MIN
    max_ending_here = 0

Loop for each element of the array
  (a) max_ending_here = max_ending_here + a[i]
  (b) if(max_so_far < max_ending_here)
            max_so_far = max_ending_here
  (c) if(max_ending_here < 0)
            max_ending_here = 0
return max_so_far

14. 14th Problem - Tìm cặp điểm gần nhất
	+ Vét cạn -> Tìm khoảng cách của từng cặp điềm -> O(n^2) -> Chú ý tọa độ x, y theo kiểu long
	
15. 15th Problem - 35. Search Insert Position - https://leetcode.com/problems/search-insert-position/
	+ Vét cạn -> Duyệt từng phần tử -> Kiểm tra khóa -> Nếu bằng -> trả về vị trí tồn tại
														Nếu khác -> kiểm tra xem khóa nhỏ hơn phần tử đầu -> 0
																 -> kiểm tra xem khóa lớn hơn phần tử cuối -> n - 1
																 ->	kiểm tra khóa có vừa lớn hơn phần tử đó vừa nhỏ hơn phần tử kế cận -> trả về vị trí chèn
	+ Binary search -> Khóa bằng mid -> Insert vào phần tử low nếu k thấy khóa
	
16. 16th Problem - https://www.spoj.com/problems/ABCDEF/
	+ Vét cạn -> Duyệt từng phần tử thỏa mãn -> tăng result lên 1 => O(n^6)
	+ Chuyển biểu thức thành 2 mảng => Tìm số phần tử của mảng 1 trong mảng 2 (lưu ý 2 mảng nên sắp xếp, đếm bằng vị trí trên - vị trí dưới) => O (n^3 * logn)
	
17. 17th Problem - Difficulty of an array - https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d3f5b
	+ Vét cạn D từ 1 -> phần tử cuối (do dãy tăng dần). Với mỗi D kiểm tra xem số phần tử thêm vào có thỏa mãn nhỏ hơn k không => O(n^2)
	+ Nhận xét D đã sắp xếp giảm dần, có thể dùng binary search để tìm D trong khoảng từ 0 -> v[N-1] - v[0] (đk lặp: l < r - 1) D = r => O(nlogn)
	
18. 18th Problem - Socially Distancing - Problem D, LG code jam Online Round 1 - https://codejam.lge.com/contest/problem/609/4
	+ Tương tự bài 17
	
19. 19th Problem - Cho số tự nhiên n ≤ 100. Hãy cho biết bao nhiêu cách phân tích số n thành tổng của các số nguyên dương, các hoán vị của nhau chỉ tính là một cách
	Xây dựng công thức truy hồi:  F[m,v] là số cách phân tích số v thành tổng các số nguyên dương ≤ m
	+ F[m,v] = F[m-1,v] nếu m > v
	+ F[m,v] = F[m-1, v] + F[m, v-m] nếu m ≤ v.
	+ F[0,0] = 1 và F[0,v] = 0 với mọi v > 0.
	+ Cách thông thường: để tính các phần tử trong bảng F phải tuân theo thứ tự thừ trên xuống, và trên mỗi hàng thì từ trái qua phải.
	+ Cách đệ quy: không quan tâm thứ tự tính toán. Có thể tối ưu bộ nhớ không tính toán lại nhiều lần bằng cách: Ban đầu giá trị của mảng là "chưa biết" (gán cho một giá trị đặt biệt), hàm getF(m,v) khi được gọi sẽ tra cứu đến F[m,v] nếu F[m,v] là chưa biết thì hàm getF(m,v) sẽ gọi đệ quy để tính F[m,v] rồi dùng giá trị này là kết quả của hàm. Còn nếu F[m,v] đã biết thì hàm chỉ việc dùng giá trị của F[m,v] là kết quả của hàm.

20. 20thProblem - https://www.spoj.com/problems/LIS/ - Dãy con đơn điệu tăng dài nhất
	+ Dùng kỹ thuật lính canh -> Bổ xung hai vào dãy A hai phần tử a0 = -∞ và a(n+1) = +∞. Khi đó dãy con đơn điệu tăng dài nhất chắc chắn sẽ bắt đầu từ a0 và kết thúc ở a(n+1)
	+ Với mọi i: 0 ≤ i ≤ n+1. Ta sẽ tính L[i] là độ dài dãy con đơn điệu dài nhất bắt đầu từ vị trí thứ i đến vị trí n+1.
	Cơ sở quy hoạch động:
		L[n+1] = 1. Dãy con này chỉ gồm một phần tử +∞.
	Công thức truy hồi:
		Xét tất cả chỉ số j từ i+1 đến n+1 mà a(j) > a(i), chọn ra chỉ số jmax mà có L[jmax] là lớn nhất. Đặt L[i] = L[jmax] +1.
	Truy vết:
		Tại mỗi bước xây dựng L[i], mỗi ghi ta gán L[i] = L[jmax] +1, ta đặt T[i] = jmax. Để lưu lại rằng dãy con dài nhất bắt đầu tại a(i) sẽ có phần tử kế tiếp là a(jmax).
		T[0] là phần tử đầu tiên được chọn.
		T[T[0]] là phần tử thứ hai được chọn.
		T[T[T[0]]] là phần tử thứ ba được chọn.
		
21. 21thProblem - https://www.spoj.com/problems/KNAPSACK/ - Bài toán cái túi (knapsack)
	F[i,j] là giá trị lớn nhất có thể có bằng cachs chọn trong các gói {1, 2, ..., i} với giới hạn trọng lượng là j => giá trị lớn nhất khi được chọn trong n gói với giới hạn trọng lượng M chính là F[n,M].

	Công thức truy hồi:
		Nếu không chọn gói thứ i F[i,j] = F[i-1,j]
		Nếu chọn gói thứ i (trong điều kiện W(i) ≤ j) F[i,j] = V[i] + F[i-1, j-W[i]].
		F[i,j] sẽ là giá trị lớn nhất trong hai giá trị thu được ở trên.
	Cơ sở quy hoạch động:
		Dễ thấy F[0,j] = 0. Do không có gói nào để lựa chọn.
	Tính bảng phương án:
		Bảng phương án F gồm n+1 dòng, M + 1 cột, trước tiên điền cơ sở quy hoạch động
		Dòng 0 gồm toàn số 0. Sử dụng công thức truy hồi, dùng dòng thứ 0 tính dòng thứ 1, dùng dòng thứ 1 tính dòng thứ 2,.... đến khi tính hết dòng thứ n.
		Truy vết:
			Tính xong bảng phương án thì ta quan tâm đến F[n,M], là giá trị lớn nhất thu được khi chọn trong n gói với giới hạn trọng lượng M.
			Nếu F[n,M] = F[n-1,M] thì tức là ta không chọn gói thứ n, ta truy vết tiếp từ F[n-1,M].
			Còn nếu F[n,M] ≠ F[n-1,M], thì ta thông báo rằng phương án tối ưu có chọn gói thứ n và tiếp tục truy vết tiêp từ F[n-1, M-W[n]].
			Cứ tiếp tục cho đến khi đến hàng 0 của bảng phương án.

22. 22thProblem - https://www.spoj.com/problems/EDIST/ - Biến đổi xâu
	Đôi với xâu ký tự, việc chèn hay xóa sẽ làm cho các phần tử phía sau vị trí biến đổi bị đánh chỉ số lại, gây khó khăn cho việc quản lý vị trí. Để khắc phục điều này, ta sẽ tìm một thứ tự biến đổi thỏa mãn:
	Phép biến đổi tại vị trí i bắt buộc phải thực hiện sau các phép biến đổi tại vị trí i+1, i+2,...
	Công thức truy hồi:
		Giả sử m là độ dài của xâu X, n là độ dài của xâu Y. Gọi F[i,j] là số phép biến đổi tối thiểu để biên xâu gồm i ký tự đầu của xâu X: X1X2..Xi thành j ký tự đầu tiên của xâu Y: Y1Y2...Yj.
		Ta nhận thấy nếu X(m) = Y(n) thì ta chỉ cần biến đoạn X1X2....X(m-1) thành Y1Y2...Yn-1: Trong trường hợp này F[m,n] = F[m-1, n-1]
		Nếu X(m) ≠ Y(n) thì tại vị trí X(m) ta có thể sử dụng một trong ba phép biến đổi:
			1. Chèn vào sau vị trị m của X một ký tự đúng bằng Y(n): F[m,n] = 1 + F[m, n-1]
			2. Thay vị trí m của X bằng một ký tự đúng bằng Y(n): F[m,n] = 1 + F[m -1, n-1]
			3. Xóa vị trí thứ m của X: F[m,n] = 1 + F[m -1, n]
			Vì F[m,n] phải là nhỏ nhất nên trong trường hợp X(m) ≠ Y(n) thì
				F[m,n] = min(F[m, n-1],  F[m -1, n-1], F[m -1, n]) + 1
	Cơ sở quy hoạch động:
		F[0,j] là số phép biến đổi xâu rỗng thành xâu j ký tự. Do đó nó cần tối thiểu j phép chèn: 
			F[0,j] = j

		F[i,0] là số biến đổi xâu i ký tự ban đầu thành xâu rông. Do đó nó cần thối thiểu i phép xóa:
			F[i,0] = i

		Vậy thì đầu tiên bảng phương án F được khởi tạo hàng 0 và cột 0 là cơ sở quy hoạch động. Từ đó dùng công thức truy hồi để tính ra tất cả các phần tử bảng phương án F.
		Sau khi tính xong F[m,n] cho ta biết số phép biến đổi tối thiểu.
	
	Truy vết:
		Nếu X(m) = Y(n) thì chỉ việc xét tiếp F[m-1, n-1].
		Nếu không, xét ba trường hợp:
			Nếu F[m,n] = F[m,n-1] + 1 thì phép biến đổi đầu tiên được sử dụng là: Insert(m, Y(n))
			Nếu F[m,n] = F[m-1,n-1] + 1 thì phép biến đổi đầu tiên được sử dụng là: Replace(m, Y(n))
			Nếu F[m,n] = F[m-1,n] + 1 thì phép biến đổi đầu tiên được sử dụng là: Delete(m)
			Đưa về bài toán m,n nhỏ hơn và truy vết tiếp cho tới khi về F[0,0].


23. 23thProblem - Biểu diễn đồ thị
	Ma trận kề: dùng 1 ma trận vuông V x V, với A[u,v] = 1
	Danh sách cạnh: dùng 1 vector với cấu trúc dữ liệu là Edge (chứa thông tin 2 đỉnh u, v)
	Danh sách kề: dùng 1 vector với số lượng tương ứng với số đỉnh V, trong từng phần tử là 1 vector chứa các đỉnh kề với đỉnh đó
	
24. 24thProblem - Biểu diễn cây nhị phân tìm kiếm
	Structure Node (data, left, right)
	Thêm phần tử vào BST
		Nếu bạn để ý, bạn sẽ nhận ra vị trí của các Node được thêm vào sẽ luôn Node lá(không có Child nào hết). Như vậy, tại vị trí đó trước khi các Node mới tới ở thì nó là NULL. 
		Ta có quy trình như sau:
			Nếu Node hiện tại = NULL, đó là vị trí cần thêm. Thêm vào BST và kết thúc
			Nếu giá trị cần thêm < giá trị root hiện tại, gọi đệ quy Insert vào cây con bên trái
			Nếu giá trị cần thêm > giá trị root hiện tại, gọi đệ quy Insert vào cây con bên phải.
	Xóa Node trong BST
		Node cần xóa là Node lá(không có child nào cả)
			Đơn giản là chỉ cần giải phóng ô nhớ đó
		Node cần xóa có 1 child
			Node bị xóa sẽ được giải phóng và cây con duy nhất của Node bị xóa sẽ được liên kết trực tiếp với cha của Node bị xóa.
		Node cần xóa có đủ 2 child
			Tìm Node của con trái nhất(giả sử nó là leftmost) của cây con bên phải của Node cần xóa.
			Cập nhật giá trị của Node cần xóa = giá trị của Node leftmost.
			Gọi đệ quy hàm Delete xóa Node leftmost khỏi BST.
			
25. 25thProblem - Minimum Spanding Tree by Kruskal
		Sắp xếp tất cả các cạnh theo thứ tự tăng dần của trọng số
		Chọn cạnh min
		Check cạnh đó có tạo thành chu trình với cây khung đang dựng hay không?
			K tạo chu trình => thêm cạnh vào cây khung
			Tạo chu trình => bỏ qua
		Kiểm tra chu trình => tìm xem gốc của 2 đỉnh có trùng nhau không (đệ quy cho parent) => trùng tạo thành 1 chu trình
																							=> không trùng => hợp nhất (cây nhiều nút hơn trở thành gốc)
		
		Lặp chọn cạnh (V -1 hoặc hết cạnh)
		main_1.cpp (node tính từ 0)
		main.cpp (node tính từ 1)
		
26. 26thProblem - Minimum Spanding Tree by Prim v1
		Khởi tạo một cây với một đỉnh duy nhất, đỉnh này được chọn tùy ý từ đồ thị V.
		Phát triển cây bằng cách thêm một cạnh vào cây đang có. Cạnh này là cạnh có trọng số nhỏ nhất trong những cạnh nối với cây từ những đỉnh chưa thuộc cây.
		Lặp lại bước 2 cho đến khi tất cả các đỉnh đều nằm trong cây (tức là lặp lại V-1 lần).
		Dùng ma trận kề -> O(V^2)
		main_1.cpp (node tính từ 0)
		main.cpp (node tính từ 1)
		
27. 27thProblem - Minimum Spanding Tree by Prim v2
		Dùng MinHeap (vector + sort) + Danh sách kề -> O(ElogV)
		main_1.cpp (node tính từ 0)
		main.cpp (node tính từ 1)
		
28. 28thProblem - Djisktra - Sử dụng ma trận kề
		Đánh dấu toàn bộ các nút là chưa thăm. Tạo ra một tập chứa toàn bộ các nút chưa thăm gọi là unvisited set.
		Gán cho mọi nốt khoảng cách dự kiến từ S. Đặt bằng 0 cho nút S d[S] = 0 và +∞ cho tất cả các nút khác d[i] = +∞ với mọi i ≠ S. Đặt nút hiện tại u là S.
		So sánh khoảng cách dự kiến hiện tại của các đỉnh v lân cận với u và khoảng cách nếu đi từ S → u → v. Nếu đi qua u gần hơn, cập nhật lại khoảng cách dự kiến của v là d[v].
		Loại bỏ nút u ra khỏi unvisited set.
		Lấy nút u nằm ở trong unvisited set mà có d[u] là nhỏ nhất