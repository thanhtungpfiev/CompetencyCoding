1. 1stProblem - 81. Search in Rotated Sorted Array II (Leet code)
+ Native search => O(n)
+ Binary search => O(logn) (mid = target break; mid < target start = mid + 1; mid > target end = mid - 1)
	=> 2 dãy sắp xếp tăng dần => Phần tử start của dãy 1 luôn luôn lớn hơn các phần tử của dãy 2
	=> Xét vị trí của mid (start + (end - start) / 2) và target xem đang nằm trong dãy nào để tìm ra khoảng binary search kế tiếp
	=> Các phần tử trùng nhau => không thể áp dụng binary search => so sánh với phần tử start => nếu bằng thì tăng start lên 1 để có khoảng binary search kế tiếp 
	
2. 2ndProblem - 33. Search in Rotated Sorted Array (Leet code)
+ Binary search => find the index of pivot => compare with last index value (vì dãy tách thành 2 dãy tăng dần, phần tử cuối là phần tử lớn nhất của dãy nhỏ, phần tử chốt là phần tử lớn nhất trong toàn dãy)

3. 3rdProblem - 5. Longest Palindromic Substring (Leet code)
+ Exhaustive search => Lấy từng chuỗi O(n^2) => Kiểm tra xem chuỗi có phải là palindromic không O(n) => Chi phí là O(n^3)
+ Giảm không gian tìm kiếm
	+ Dùng biến giữ giá trị lớn nhất của chuỗi con hiện tại, nếu cấu hình kiểm tra có độ dài nhỏ hơn thì bỏ qua.
+ Sắp xếp lại không gian tìm kiếm
	+ Bắt đầu tìm từ chuỗi dài nhất rùi giảm dần đến chuỗi nhỏ hơn
+ DP 
	P[i,i] = true // 1 letter
	P[i, i + 1] = (s[i] == s[i + 1]) // 2 letters
	P[i,j] = P[i + 1, j - 1] && s[i] == s[j] // >= 3 letters
		
4. 4thProblem - REPROAD - Repair road (spoj)
+ Exhaustive search => Lấy từng cấu hình O (n^2) => Kiểm tra xem độ dài cấu hình (đoạn đang xét) có lớn hơn max && kiểm tra đoạn đó có phải là đoạn thỏa mãn lượng số 0 < K (cost) hay không
+ Stack 
Dùng tham lam: Nhận xét thấy rằng việc khác nhau giữa hai cấu hình hợp lệ (i1,j1) và (i2, j2)
trong đó i1 <i2, j1 < j2 phải thỏa mãn: Số số 0 nằm trong khoảng i1 đến i2 nhỏ hơn hoặc bằng số
số 0 nằm trong j1 đến j2.
Do đó, việc tính toán cấu hình tiếp theo từ cấu hình hiện có (i1, j1) bằng cách tăng i1 lên thành i2
với số số 0 nằm trong i1 và i2 là 1 số 0. Tương tự với j1 và j2.
Cấu hình đầu tiên hợp lệ là cấu hình đã sửa K đoạn hỏng đầu tiên.
Bằng cách stack lại các vị trí của i, ta có thể loại bỏ việc tìm i2 -> giảm độ phức tạp xuống còn
O(n)

=> 1 vòng for duyệt toàn bộ dãy => Kiểm tra phần tử đó là 0 hay 1
	=> Nếu là 0 => nếu cost < K => tăng cost và len lên 1 đơn vị
					nếu không => tính lại đoạn khác len = i - q.front(), q.pop_front(); (số 0 mới đc đưa vào vị trí neo sau khi K lần sửa đã được áp dụng)
				đưa i vào stack là mốc của số 0 hiện tại
	+ Nếu không thì tăng len lên (vì đoạn đó là 1)
	+ Check kết quả bằng max của len và kết quả

5. 5thProblem - Liệt kê cấu hình cho bài toán n!
	+ Phương pháp sinh
		Khởi đầu với 1 cấu hình tăng dần từ 1 -> n (nhưng khi code thì nên tạo mảng có n + 1 phần tử, với phần tử đầu tiên là 0)
		Tìm dãy con giản dần dài nhất
		Tim phần tử đầu tiên trong dãy con đó lớn hơn i - 1 (phần tử đứng kế ngày trc dãy con)
		Đảo 2 phần tử cho nhau
		Đổi dãy con giảm dần thành dãy con tăng dần
		Kết thúc khi dãy toàn phần tử giảm dần
	+ Quay lui
		Dùng 1 mảng đánh dấu
		Thử từ 1
		Duyệt từ v = 1 -> n
		Neu mark[v] chưa đánh dấu => gán giá trị => Nếu là cấu hình cuối (i == n) => In giá trị
														Nếu không => Đánh dấu phần tử thứ v là đã chọn => Thử với i + 1 => Bỏ đánh dấu phần tử thứ v
6. 6thProblem - Liệt kê cấu hình cho bài toán Akn (n!/)n-k)!)
Tương tự bài toán 5 nhưng tốt nhất nên dùng thuật toán quay lui với điều kiên thay n bằng k ở cấu hình cuối

7. 7th Problem - Liệt kê cấu hình cho bài toán Ckn = Akn/n!
	+ Phương pháp sinh
		1. Tìm từ cuối lên đầu dãy cho đến khi gặp phần tử x(i) chưa đạt giới hạn trên n - k + i.
		2. Tăng x(i) lên một đơn vị.
		3. Đặt lại tất cả các phần tử phía sau bằng giới hạn dưới.
	+ Quay lui
		Xét tất cả các cách chọn x1 từ 1 (x0 + 1) đến n - k + 1, với mỗi giá trị đó xét tất cả các lựa chọn x2 từ x1+1 đến n - k + 2, ...., cứ như vậy đến x(k) thì ta có cấu hình cần liệt kê.
		=> giá trị v chạy từ x[i - 1] + 1 -> n - k + i
		Thử từ 1 -> n
		
8. 8th Problem - Liệt kê dãy nị phân có độ dài n
	+ Quay lui
		Giá trị gán v chạy trong khoảng 0, 1
		Thử từ i = 1 -> n

9. 9th Problem - https://www.spoj.com/problems/BURGLARY/
	+ Liệt kê 2^n dãy nhị phân, với 1 ứng với phần tử j đc chọn, và 0 không được chọn
	+ Chia đôi dãy, dùng map (Liệt kê tất cả các dãy con của n/2) => kiểm tra từng dãy có tổng nào chọn được bằng nhiều số K không => Tổng hợp lại. Nếu từng dãy có value sum = -2 thì bỏ, không thì tính số lượng phần tử hiện tại bằng tổng, kiểm tra giá trị trước xem có khác không, nếu khác thì cho là -2, không thì lưu lại.
		Lưu ý trong lúc sinh phải kiếm tra tổng bằng 0 có hình thành bằng các phần tử 0 không, nếu có thì cho bằng -2, không thì cho bằng 0.
		Các tổng khác 0 thì sẽ kiểm tra xem đã update vào map chưa, nếu chưa thì lưu value bằng số lượng phần tử, nếu rồi thì lưu value = -2

10. 10th Problem - QuickSort

11. 11th Problem - Searching
	+ Sequence search - Tìm kiềm lần lượt dãy khóa -> O(n)
	+ Binay search -> Dãy khóa đã sắp xếp -> Chia đôi dãy khóa để tìm -> O(logn) 
		mid = start + (end - start) / 2
		while (start <= end) search key and update start/end bằng mid

12. 12th Problem - Merge sort - TopDown 
	if (i < iMiddle && (j >= iEnd || A[i] < A[j])) { //nếu dãy bên trái vẫn còn phần tử kết hợp với dãy bên phải hết phần tử hoặc cả hai dãy vẫn còn phần tử nhưng phần tử bên trái nhỏ hơn phần tử bên phải.
	
13. 13th Problem - Tìm tập con liên tục có tổng lớn nhất
	+ Vét cạn -> tính tổng từng tập con -> tìm tập có tổng lớn nhất -> O(n^3)
	+ Áp dụng chia để trị ta có thể giải bài toán này theo cách sau:

Chia mảng ban đầu thành hai mảng
Trả ra tổng lớn nhất của:
Tổng lớn nhất của mảng bên trái (bằng cách gọi đệ quy)
Tổng lớn nhất của mảng bên phải (bằng cách gọi đệ quy)
Tổng lớn nhất của mảng gồm phần tử cả phần tử ở giữa
	+ Thuật toán Kadane
	
Initialize:
    max_so_far = INT_MIN
    max_ending_here = 0

Loop for each element of the array
  (a) max_ending_here = max_ending_here + a[i]
  (b) if(max_so_far < max_ending_here)
            max_so_far = max_ending_here
  (c) if(max_ending_here < 0)
            max_ending_here = 0
return max_so_far

14. 14th Problem - Tìm cặp điểm gần nhất
	+ Vét cạn -> Tìm khoảng cách của từng cặp điềm -> O(n^2) -> Chú ý tọa độ x, y theo kiểu long
	
15. 15th Problem - 35. Search Insert Position - https://leetcode.com/problems/search-insert-position/
	+ Vét cạn -> Duyệt từng phần tử -> Kiểm tra khóa -> Nếu bằng -> trả về vị trí tồn tại
														Nếu khác -> kiểm tra xem khóa nhỏ hơn phần tử đầu -> 0
																 -> kiểm tra xem khóa lớn hơn phần tử cuối -> n - 1
																 ->	kiểm tra khóa có vừa lớn hơn phần tử đó vừa nhỏ hơn phần tử kế cận -> trả về vị trí chèn
	+ Binary search -> Khóa bằng mid -> Insert vào phần tử low nếu k thấy khóa
	
16. 16th Problem - https://www.spoj.com/problems/ABCDEF/
	+ Vét cạn -> Duyệt từng phần tử thỏa mãn -> tăng result lên 1 => O(n^6)
	+ Chuyển biểu thức thành 2 mảng => Tìm số phần tử của mảng 1 trong mảng 2 (lưu ý 2 mảng nên sắp xếp, đếm bằng vị trí trên - vị trí dưới) => O (n^3 * logn)
	
17. 17th Problem - Difficulty of an array - https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d3f5b
	+ Vét cạn D từ 1 -> phần tử cuối (do dãy tăng dần). Với mỗi D kiểm tra xem số phần tử thêm vào có thỏa mãn nhỏ hơn k không => O(n^2)
	+ Nhận xét D đã sắp xếp giảm dần, có thể dùng binary search để tìm D trong khoảng từ 0 -> v[N-1] - v[0] (đk lặp: l < r - 1) D = r => O(nlogn)
	
18. 18th - Socially Distancing - Problem D, LG code jam Online Round 1 - https://codejam.lge.com/contest/problem/609/4
	+ Tuowng tự bài 17